import argparse
import os
import re
import sys
import time
from collections import Counter
from contextlib import contextmanager
from datetime import datetime, timezone

import jpype
from matplotlib import pyplot as plt
from sqlalchemy import asc, create_engine
from sqlalchemy.orm import Session

from config import LOCAL_SQL_HOSTNAME, LOCAL_SQL_PASSWORD, LOCAL_SQL_USERNAME
from donguri_gaeru.database import Match, Player

from .algorithm import Rating, hikuwr_rating

parser = argparse.ArgumentParser(
    description=(
        "Run World Ranking rating algorithm validation routines as of 01/02/20.\n"
        "Default threshold for Python algorithm is 1e-6 (maximum rating delta)."
    ),
    formatter_class=argparse.RawTextHelpFormatter,
)
parser.add_argument(
    "-a",
    "--algorithm",
    nargs="?",
    const="1e-6",
    metavar="THRESHOLD",
    help="compare algorithm results between the Wiki, Java, and Python",
)
parser.add_argument(
    "-c",
    "--convergence",
    nargs="?",
    const="1e-6",
    metavar="THRESHOLD",
    help="plot the algorithm convergence metrics",
)
parser.add_argument(
    "-m",
    "--matchups",
    nargs="?",
    const="250",
    metavar="N",
    help="list the most common player matchups (default 250)",
)


@contextmanager
def dbsession(dbname):
    sql = "postgresql://{username}:{password}@{hostname}/{database}"
    url = sql.format(
        username=LOCAL_SQL_USERNAME,
        password=LOCAL_SQL_PASSWORD,
        hostname=LOCAL_SQL_HOSTNAME,
        database=dbname,
    )
    engine = create_engine(url)
    with engine.connect() as connection:
        with Session(bind=connection) as session:
            yield session

    engine.dispose()


class TimedMsg:
    def __init__(self):
        self.start = time.time()

    def __call__(self, msg):
        end = time.time()
        print("   - {} ({:0.1f}s elapsed)".format(msg, end - self.start))
        self.start = end


asof_date = datetime(2020, 2, 1, tzinfo=timezone.utc)
basepath = os.path.dirname(__file__)


def validate_algorithm(threshold):
    # This routine will validate the Python algorithm implementation.
    # See results/validate_algorithm.txt for the output which compares:
    #   1) The ratings posted on the bayoen.fr world ranking page as of February 2020.
    #   2) The ratings generated by the original Java code (with minor adjustments).
    #   3) The ratings generated by the Python code adaptation.

    # Open the hikuwr database and query all matches prior to February 2020.
    fstring = "validate_algorithm (as of {}, threshold={:0.2g})"
    print(fstring.format(asof_date.strftime("%d/%m/%y"), threshold))

    with dbsession(dbname="hikuwr") as session:
        msg = TimedMsg()
        matches = (
            session.query(Match)
            .filter(Match.created <= asof_date)
            .order_by(asc(Match.created))
            .all()
        )
        msg("Load {:d} matches from database.".format(len(matches)))

        # Compute the results for comparison.
        wiki_results = load_wiki_results(session)
        msg("Load {:d} ratings from wiki.".format(len(wiki_results)))

        times = 50000
        java_results = load_java_results(session, matches, asof_date, times)
        msg("Compute ratings with Java algorithm, {:d} iterations.".format(times))

        python_results, info = hikuwr_rating(matches, asof_date, threshold, info=True)
        msg("Compute ratings with Python algorithm, {:d} iterations.".format(info.n))

    # Get the set of players common to all three results, sorted by wiki minimum rating.
    players = set(wiki_results) & set(java_results) & set(python_results)
    players = sorted(players, key=lambda player: wiki_results[player].min, reverse=True)
    results = [
        ("wiki", wiki_results),
        ("java", java_results),
        ("python", python_results),
    ]

    # Write the results to file.
    filename = "validate_algorithm.txt"
    filepath = os.path.join(basepath, "results", filename)
    fstring = "{src}\t{name}\t{min:0.2f}\t{med:0.2f}\t{max:0.2f}\n"
    with open(filepath, "w", encoding="utf-8") as file:
        file.write("Ratings as of " + asof_date.strftime("%d/%m/%y") + ".\n")
        file.write("Java Iterations=50000\n")
        file.write("Python Threshold={:0.2g}\n\n".format(threshold))
        for player in players:
            for src, result in results:
                file.write(
                    fstring.format(
                        src=src,
                        name=player.name,
                        min=result[player].min,
                        med=result[player].med,
                        max=result[player].max,
                    )
                )
            file.write("\n")


def load_wiki_results(session):
    # Load the dateset from the text file.
    filepath = os.path.join(os.path.dirname(__file__), "source", "ratings_feb_2020.txt")
    with open(filepath, "r", encoding="utf-8") as file:
        lines = file.readlines()

    # Parse the dataset and return a dictionary. Query the database by player name.
    decimal = r"\s(\d+.\d\d)"
    pattern = r"^\d+\s(\S+)\s\S+" + decimal * 3 + "$"
    ratings = dict()
    for match in [re.match(pattern, line) for line in lines]:
        if match is None:
            continue

        player = session.query(Player).filter(Player.name == match.group(1)).first()

        if player is not None:
            ratings[player] = Rating(
                min=float(match.group(2)),
                med=float(match.group(3)),
                max=float(match.group(4)),
            )

    return ratings


def load_java_results(session, matches, asof_date, iterations):
    jpype.startJVM(classpath=[basepath])
    WorldRanking = jpype.JClass("source/WorldRanking")()

    for match in matches:
        WorldRanking.pythonAddMatch(
            match.playerA.name,
            match.playerB.name,
            match.scoreA,
            match.scoreB,
            match.created.strftime("%d/%m/%y"),
        )

    WorldRanking.pythonExecuteAlgorithm(iterations, asof_date.strftime("%d/%m/%y"))
    output = zip(
        WorldRanking.playerNames,
        WorldRanking.playerRatings,
        WorldRanking.playerLowerBounds,
        WorldRanking.playerUpperBounds,
    )
    results = {}
    for name, med_rating, lb_rating, ub_rating in output:
        player = session.query(Player).filter(Player.name == str(name)).one()
        rating = Rating(min=lb_rating, med=med_rating, max=ub_rating)
        results[player] = rating

    jpype.shutdownJVM()
    return results


def validate_convergence(threshold):
    # This routine will plot the algorithm converge metric over iterations.
    # See results/validate_convergence.png for a plot.

    # Open the hikuwr database and query all matches prior to February 2020.
    fstring = "validate_convergence (as of {}, threshold={:0.2g})"
    print(fstring.format(asof_date.strftime("%d/%m/%y"), threshold))

    with dbsession(dbname="hikuwr") as session:
        msg = TimedMsg()
        matches = (
            session.query(Match)
            .filter(Match.created <= asof_date)
            .order_by(asc(Match.created))
            .all()
        )
        msg("Load {:d} matches from database.".format(len(matches)))

        _, info = hikuwr_rating(matches, asof_date, threshold, info=True)
        msg("Compute ratings with Python algorithm, {:d} iterations.".format(info.n))

    plt.semilogy(info.maxdeltas, label="largest rating change")
    plt.semilogy(info.avedeltas, label="average rating change")
    plt.title("Rating Change Over Iterations")
    plt.grid()
    plt.xlabel("Iterations")
    plt.ylabel("Rating Change")
    plt.legend()

    filepath = os.path.join(basepath, "results", "validate_convergence.png")
    plt.savefig(filepath)


def most_common_matchups(n):
    # See results/most_common_matchups.txt for a list.

    # Open the hikuwr database and query all matches prior to February 2020.
    fstring = "most_common_matchups (as of {}, number={:d})"
    print(fstring.format(asof_date.strftime("%d/%m/%y"), n))

    with dbsession(dbname="hikuwr") as session:
        msg = TimedMsg()
        matches = (
            session.query(Match)
            .filter(Match.created <= asof_date)
            .order_by(asc(Match.created))
            .all()
        )
        msg("Load {:d} matches from database.".format(len(matches)))

        matchup_counter = Counter()
        match_counter = Counter()
        for match in matches:
            matchup_counter[frozenset([match.playerA.name, match.playerB.name])] += 1
            match_counter[match.playerA.name] += 1
            match_counter[match.playerB.name] += 1

    filename = "most_common_matchups.txt"
    filepath = os.path.join(basepath, "results", filename)
    fstring = "{:d} matches between:\t{} ({:d} matches)\t{} ({:d} matches)\n"
    with open(filepath, "w", encoding="utf-8") as file:
        for matchup, count in matchup_counter.most_common(n):
            playerA, playerB = tuple(matchup)
            file.write(
                fstring.format(
                    count,
                    playerA,
                    match_counter[playerA],
                    playerB,
                    match_counter[playerB],
                )
            )

    msg("Most common matchups written to file.")


def main():
    if not len(sys.argv) > 1:
        parser.print_help()
        return

    args = parser.parse_args()
    if args.algorithm is not None:
        print()
        validate_algorithm(float(args.algorithm))
    if args.convergence is not None:
        print()
        validate_convergence(float(args.convergence))
    if args.matchups is not None:
        print()
        most_common_matchups(int(args.matchups))
