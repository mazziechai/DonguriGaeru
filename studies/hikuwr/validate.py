import os

# import random
import re
from contextlib import contextmanager
from datetime import datetime, timezone

import jpype
from algorithm import Rating  # , hikuwr_rating
from sqlalchemy import asc, create_engine
from sqlalchemy.orm import Session

from config import LOCAL_SQL_HOSTNAME, LOCAL_SQL_PASSWORD, LOCAL_SQL_USERNAME
from donguri_gaeru.database import Match, Player


@contextmanager
def dbsession(dbname):
    sql = "postgresql://{username}:{password}@{hostname}/{database}"
    url = sql.format(
        username=LOCAL_SQL_USERNAME,
        password=LOCAL_SQL_PASSWORD,
        hostname=LOCAL_SQL_HOSTNAME,
        database=dbname,
    )
    engine = create_engine(url)
    with engine.connect() as connection:
        with Session(bind=connection) as session:
            yield session

    engine.dispose()


def validate_algorithm():
    # This routine will validate the Python algorithm implementation.
    # See results/validate_algorithm.txt for the output which compares:
    #   1) The ratings posted on the bayoen.fr world ranking page as of February 2020.
    #   2) The ratings generated by the original Java code (with minor adjustments).
    #   3) The ratings generated by the Python code adaptation.

    asof_date = datetime(2020, 2, 1, tzinfo=timezone.utc)
    iterations = 50000

    # Open the hikuwr database and query all matches prior to February 2020.
    with dbsession(dbname="hikuwr") as session:
        matches = (
            session.query(Match)
            .filter(Match.created <= asof_date)
            .order_by(asc(Match.created))
            .all()
        )

        # random.shuffle(matches)

        # Compute the results for comparison.
        wiki_results = load_wiki_results(session)
        java_results = load_java_results(session, matches, asof_date, iterations)
        # python_results = hikuwr_rating(matches, asof_date, iterations)

    # Get the set of players common to all three results, sorted by wiki minimum rating.
    players = set(wiki_results) & set(java_results)  # & set(python_results)
    players = sorted(players, key=lambda player: wiki_results[player].min, reverse=True)
    results = [
        ("wiki", wiki_results),
        ("java", java_results),
        # ("python", python_results),
    ]

    # Write the results to file.
    filename = "validate_algorithm.txt"
    filepath = os.path.join(os.path.dirname(__file__), "results", filename)
    fstring = "{src}\t{name}\t{min:0.2f}\t{med:0.2f}\t{max:0.2f}\n"
    with open(filepath, "w", encoding="utf-8") as file:
        file.write("Ratings as of " + asof_date.strftime("%d/%m/%y") + ".\n")
        file.write(str(iterations) + " iterations.\n\n")
        for player in players:
            for src, result in results:
                file.write(
                    fstring.format(
                        src=src,
                        name=player.name,
                        min=result[player].min,
                        med=result[player].med,
                        max=result[player].max,
                    )
                )
            file.write("\n")


def load_wiki_results(session):
    # Load the dateset from the text file.
    filepath = os.path.join(os.path.dirname(__file__), "source", "ratings_feb_2020.txt")
    with open(filepath, "r", encoding="utf-8") as file:
        lines = file.readlines()

    # Parse the dataset and return a dictionary. Query the database by player name.
    decimal = r"\s(\d+.\d\d)"
    pattern = r"^\d+\s(\S+)\s\S+" + decimal * 3 + "$"
    ratings = dict()
    for match in [re.match(pattern, line) for line in lines]:
        if match is None:
            continue
        try:
            player = session.query(Player).filter(Player.name == match.group(1)).one()
            ratings[player] = Rating(
                min=float(match.group(2)),
                med=float(match.group(3)),
                max=float(match.group(4)),
            )
        except:  # noqa: E722
            pass

    return ratings


def load_java_results(session, matches, asof_date, iterations):
    jpype.startJVM(classpath=[os.path.join(os.path.dirname(__file__))])
    WorldRanking = jpype.JClass("source/WorldRanking")()

    for match in matches:
        WorldRanking.pythonAddMatch(
            match.playerA.name,
            match.playerB.name,
            match.scoreA,
            match.scoreB,
            match.created.strftime("%d/%m/%y"),
        )

    WorldRanking.pythonExecuteAlgorithm(iterations, asof_date.strftime("%d/%m/%y"))
    results = {}
    for name, med_rating in zip(WorldRanking.playerNames, WorldRanking.playerRatings):
        player = session.query(Player).filter(Player.name == str(name)).one()
        rating = Rating(min=med_rating, med=med_rating, max=med_rating)
        results[player] = rating

    jpype.shutdownJVM()
    return results


if __name__ == "__main__":
    validate_algorithm()
