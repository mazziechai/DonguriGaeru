import argparse
import os
import re
import sys
import time
from collections import Counter
from contextlib import contextmanager
from datetime import datetime, timezone

import jpype
import numpy as np
from matplotlib import pyplot as plt
from sqlalchemy import asc, create_engine
from sqlalchemy.orm import Session

from config import LOCAL_SQL_HOSTNAME, LOCAL_SQL_PASSWORD, LOCAL_SQL_USERNAME
from donguri_gaeru.database import Match, Player

from .algorithm import Rating, hikuwr_rating

parser = argparse.ArgumentParser(
    description=(
        "Run World Ranking rating system validation routines as of 01/02/20.\n"
        "Default threshold for Python algorithm is 1e-6 (maximum rating delta)."
    ),
    formatter_class=argparse.RawTextHelpFormatter,
)
parser.add_argument(
    "-a",
    "--algorithm",
    nargs="?",
    const="1e-6",
    metavar="THRESHOLD",
    help="compare algorithm results between the Wiki, Java, and Python",
)
parser.add_argument(
    "-c",
    "--convergence",
    nargs="?",
    const="1e-6",
    metavar="THRESHOLD",
    help="plot the algorithm convergence metrics",
)
parser.add_argument(
    "-m",
    "--matchups",
    nargs="?",
    const="250",
    metavar="N",
    help="list the most common player matchups (default 250)",
)
parser.add_argument(
    "-p",
    "--predicts",
    nargs=3,
    metavar=("PLAYERA", "PLAYERB", "THRESHOLD"),
    help="compute algorithm predicts for a specific matchup",
)


@contextmanager
def dbsession(dbname):
    sql = "postgresql://{username}:{password}@{hostname}/{database}"
    url = sql.format(
        username=LOCAL_SQL_USERNAME,
        password=LOCAL_SQL_PASSWORD,
        hostname=LOCAL_SQL_HOSTNAME,
        database=dbname,
    )
    engine = create_engine(url)
    with engine.connect() as connection:
        with Session(bind=connection) as session:
            yield session

    engine.dispose()


class TimedMsg:
    def __init__(self):
        self.start = time.time()

    def __call__(self, msg):
        end = time.time()
        print("   - {} ({:0.1f}s elapsed)".format(msg, end - self.start))
        self.start = end


asof_date = datetime(2020, 2, 1, tzinfo=timezone.utc)
basepath = os.path.dirname(__file__)


def validate_algorithm(threshold):
    # This routine will validate the Python algorithm implementation.
    # See results/validate_algorithm.txt for the output which compares:
    #   1) The ratings posted on the bayoen.fr world ranking page as of February 2020.
    #   2) The ratings generated by the original Java code (with minor adjustments).
    #   3) The ratings generated by the Python code adaptation.

    # Open the hikuwr database and query all matches prior to February 2020.
    fstring = "validate_algorithm (as of {}, threshold={:0.2g})"
    print(fstring.format(asof_date.strftime("%d/%m/%y"), threshold))

    with dbsession(dbname="hikuwr") as session:
        msg = TimedMsg()
        matches = (
            session.query(Match)
            .filter(Match.created <= asof_date)
            .order_by(asc(Match.created))
            .all()
        )
        msg("Load {:d} matches from database.".format(len(matches)))

        # Compute the results for comparison.
        wiki_results = load_wiki_results(session)
        msg("Load {:d} ratings from wiki.".format(len(wiki_results)))

        times = 50000
        java_results = load_java_results(session, matches, asof_date, times)
        msg("Compute ratings with Java algorithm, {:d} iterations.".format(times))

        python_results, info = hikuwr_rating(matches, asof_date, threshold, info=True)
        msg("Compute ratings with Python algorithm, {:d} iterations.".format(info.n))

    # Get the set of players common to all three results, sorted by wiki minimum rating.
    players = set(wiki_results) & set(java_results) & set(python_results)
    players = sorted(players, key=lambda player: wiki_results[player].min, reverse=True)
    results = [
        ("wiki", wiki_results),
        ("java", java_results),
        ("python", python_results),
    ]

    # Write the results to file.
    filename = "validate_algorithm.txt"
    filepath = os.path.join(basepath, "results", filename)
    fstring = "{src}\t{name}\t{min:0.2f}\t{med:0.2f}\t{max:0.2f}\n"
    with open(filepath, "w", encoding="utf-8") as file:
        file.write("Ratings as of " + asof_date.strftime("%d/%m/%y") + ".\n")
        file.write("Java Iterations=50000\n")
        file.write("Python Threshold={:0.2g}\n\n".format(threshold))
        for player in players:
            for src, result in results:
                file.write(
                    fstring.format(
                        src=src,
                        name=player.name,
                        min=result[player].min,
                        med=result[player].med,
                        max=result[player].max,
                    )
                )
            file.write("\n")


def load_wiki_results(session):
    # Load the dateset from the text file.
    filepath = os.path.join(os.path.dirname(__file__), "source", "ratings_feb_2020.txt")
    with open(filepath, "r", encoding="utf-8") as file:
        lines = file.readlines()

    # Parse the dataset and return a dictionary. Query the database by player name.
    decimal = r"\s(\d+.\d\d)"
    pattern = r"^\d+\s(\S+)\s\S+" + decimal * 3 + "$"
    ratings = dict()
    for match in [re.match(pattern, line) for line in lines]:
        if match is None:
            continue

        player = session.query(Player).filter(Player.name == match.group(1)).first()

        if player is not None:
            ratings[player] = Rating(
                min=float(match.group(2)),
                med=float(match.group(3)),
                max=float(match.group(4)),
            )

    return ratings


def load_java_results(session, matches, asof_date, iterations):
    jpype.startJVM(classpath=[basepath])
    WorldRanking = jpype.JClass("source/WorldRanking")()

    for match in matches:
        WorldRanking.pythonAddMatch(
            match.playerA.name,
            match.playerB.name,
            match.scoreA,
            match.scoreB,
            match.created.strftime("%d/%m/%y"),
        )

    WorldRanking.pythonExecuteAlgorithm(iterations, asof_date.strftime("%d/%m/%y"))
    output = zip(
        WorldRanking.playerNames,
        WorldRanking.playerRatings,
        WorldRanking.playerLowerBounds,
        WorldRanking.playerUpperBounds,
    )
    results = {}
    for name, med_rating, lb_rating, ub_rating in output:
        player = session.query(Player).filter(Player.name == str(name)).one()
        rating = Rating(min=lb_rating, med=med_rating, max=ub_rating)
        results[player] = rating

    jpype.shutdownJVM()
    return results


def validate_convergence(threshold):
    # This routine will plot the algorithm convergence metric over iterations.
    # See results/validate_convergence.png for a plot.

    # Open the hikuwr database and query all matches prior to February 2020.
    fstring = "validate_convergence (as of {}, threshold={:0.2g})"
    print(fstring.format(asof_date.strftime("%d/%m/%y"), threshold))

    with dbsession(dbname="hikuwr") as session:
        msg = TimedMsg()
        matches = (
            session.query(Match)
            .filter(Match.created <= asof_date)
            .order_by(asc(Match.created))
            .all()
        )
        msg("Load {:d} matches from database.".format(len(matches)))

        _, info = hikuwr_rating(matches, asof_date, threshold, info=True)
        msg("Compute ratings with Python algorithm, {:d} iterations.".format(info.n))

    plt.semilogy(info.maxdeltas, label="largest rating change")
    plt.semilogy(info.avedeltas, label="average rating change")
    plt.title("Rating Change Over Iterations")
    plt.grid()
    plt.xlabel("Iterations")
    plt.ylabel("Rating Change")
    plt.legend()

    filepath = os.path.join(basepath, "results", "validate_convergence.png")
    plt.savefig(filepath)


def matchups(n):
    # See results/matchups.txt for a list.

    # Open the hikuwr database and query all matches prior to February 2020.
    fstring = "matchups (as of {}, number={:d})"
    print(fstring.format(asof_date.strftime("%d/%m/%y"), n))

    with dbsession(dbname="hikuwr") as session:
        msg = TimedMsg()
        matches = (
            session.query(Match)
            .filter(Match.created <= asof_date)
            .order_by(asc(Match.created))
            .all()
        )
        msg("Load {:d} matches from database.".format(len(matches)))

        matchup_counter = Counter()
        match_counter = Counter()
        for match in matches:
            matchup_counter[frozenset([match.playerA.name, match.playerB.name])] += 1
            match_counter[match.playerA.name] += 1
            match_counter[match.playerB.name] += 1

    filepath = os.path.join(basepath, "results", "matchups.txt")
    fstring = "{:d} matches between:\t{} ({:d} matches)\t{} ({:d} matches)\n"
    with open(filepath, "w", encoding="utf-8") as file:
        for matchup, count in matchup_counter.most_common(n):
            playerA, playerB = tuple(matchup)
            file.write(
                fstring.format(
                    count,
                    playerA,
                    match_counter[playerA],
                    playerB,
                    match_counter[playerB],
                )
            )

    msg("Most common matchups written to file.")


def validate_predicts(playerA, playerB, threshold):
    # Remove from the matchup list any matches between the two players.
    # At the time of each match, compute player ratings and compare the
    # predicted score range against the actual result.
    # See results/validate_predicts/playerA_vs_playerB.png for a plot.

    # Open the hikuwr database and query all matches prior to February 2020.
    fstring = "validate_predicts (as of {}, {} vs {})"
    print(fstring.format(asof_date.strftime("%d/%m/%y"), playerA, playerB))

    with dbsession(dbname="hikuwr") as session:
        msg = TimedMsg()
        matches = (
            session.query(Match)
            .filter(Match.created <= asof_date)
            .order_by(asc(Match.created))
            .all()
        )
        matchfilt = lambda m: {playerA, playerB} != {  # noqa: E731
            m.playerA.name,
            m.playerB.name,
        }
        base = list(filter(matchfilt, matches))
        predict = list(filter(lambda m: not matchfilt(m), matches))
        fstring = "Load {:d} matches from database, {:d} matches to predict."
        msg(fstring.format(len(base), len(predict)))

        ratings = []
        for i, match in enumerate(predict):
            datefilt = lambda m: m.created <= match.created  # noqa: E731
            matches_to_rate = list(filter(datefilt, base))
            rating = hikuwr_rating(matches_to_rate, match.created, threshold)
            ratings.append((match, rating))
            msg("Ratings computed for match {:d} of {:d}.".format(i + 1, len(predict)))

        dates = []
        ratingA = []
        ratingB = []
        ratingAerr = []
        ratingBerr = []
        score_predict = []
        score_predict_err = []
        score_actual = []
        for match, rating in ratings:
            dates.append(match.created)
            if match.playerA.name == playerA:
                ratingAbnd = rating[match.playerA]
                ratingBbnd = rating[match.playerB]
                scoreA = match.scoreA
            else:
                ratingAbnd = rating[match.playerB]
                ratingBbnd = rating[match.playerA]
                scoreA = match.scoreB

            # Get the player ratings over time.
            ratingA.append(ratingAbnd.med)
            ratingAerr.append(
                [ratingAbnd.med - ratingAbnd.min, ratingAbnd.max - ratingAbnd.med]
            )
            ratingB.append(ratingBbnd.med)
            ratingBerr.append(
                [ratingBbnd.med - ratingBbnd.min, ratingBbnd.max - ratingBbnd.med]
            )

            # Predict the matchup results over time.
            score_actual.append(scoreA / match.games)
            predict = 1 / (ratingBbnd.med / ratingAbnd.med + 1)
            lo_predict = 1 / (ratingBbnd.max / ratingAbnd.min + 1)
            hi_predict = 1 / (ratingBbnd.min / ratingAbnd.max + 1)
            score_predict.append(predict)
            score_predict_err.append([predict - lo_predict, hi_predict - predict])

    fig, axs = plt.subplots(2, 1, figsize=(6, 8), sharex=True)

    axs[0].errorbar(
        dates,
        ratingA,
        yerr=np.transpose(ratingAerr),
        fmt=".",
        capsize=2,
        label="PlayerA: " + playerA,
    )
    axs[0].errorbar(
        dates,
        ratingB,
        yerr=np.transpose(ratingBerr),
        fmt=".",
        capsize=2,
        label="PlayerB: " + playerB,
    )
    axs[0].grid(which="both")
    axs[0].legend()
    axs[0].set_ylabel("Player Ratings")

    axs[1].errorbar(
        dates,
        score_predict,
        yerr=np.transpose(score_predict_err),
        fmt=".",
        capsize=2,
        label="predict",
    )
    axs[1].plot(dates, score_actual, "rx", label="actual")
    axs[1].grid(which="both")
    axs[1].legend()
    axs[1].set_ylabel("PlayerA Fractional Win Total")

    [tick.set_rotation(30) for tick in axs[1].get_xticklabels()]

    filename = "{}_vs_{}.png".format(playerA, playerB)
    filepath = os.path.join(basepath, "results", "validate_predicts", filename)
    plt.savefig(filepath)


def main():
    if not len(sys.argv) > 1:
        parser.print_help()
        return

    args = parser.parse_args()
    if args.algorithm is not None:
        print()
        validate_algorithm(float(args.algorithm))
    if args.convergence is not None:
        print()
        validate_convergence(float(args.convergence))
    if args.matchups is not None:
        print()
        matchups(int(args.matchups))
    if args.predicts is not None:
        print()
        validate_predicts(args.predicts[0], args.predicts[1], float(args.predicts[2]))
