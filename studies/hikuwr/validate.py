import argparse
import os
import re
import sys
import time
from contextlib import contextmanager
from datetime import datetime, timezone

import jpype
from matplotlib import pyplot as plt
from sqlalchemy import asc, create_engine
from sqlalchemy.orm import Session

from config import LOCAL_SQL_HOSTNAME, LOCAL_SQL_PASSWORD, LOCAL_SQL_USERNAME
from donguri_gaeru.database import Match, Player

from .algorithm import Rating, hikuwr_rating

parser = argparse.ArgumentParser(
    description="Run various World Ranking rating algorithm validation routines.",
    formatter_class=argparse.RawTextHelpFormatter,
)
parser.add_argument(
    "-a",
    "--algorithm",
    nargs="?",
    const="10000",
    help=(
        "compare WorldRanking algorithm between the Wiki, Java, and Python\n"
        "as of Feb. 2020 (default 10000 iterations)"
    ),
)
parser.add_argument(
    "-c",
    "--convergence",
    nargs="?",
    const="10000",
    help=(
        "plot the WorldRanking algorithm convergence metric (default 10000 iterations)"
    ),
)


@contextmanager
def dbsession(dbname):
    sql = "postgresql://{username}:{password}@{hostname}/{database}"
    url = sql.format(
        username=LOCAL_SQL_USERNAME,
        password=LOCAL_SQL_PASSWORD,
        hostname=LOCAL_SQL_HOSTNAME,
        database=dbname,
    )
    engine = create_engine(url)
    with engine.connect() as connection:
        with Session(bind=connection) as session:
            yield session

    engine.dispose()


def validate_algorithm(iterations):
    # This routine will validate the Python algorithm implementation.
    # See results/validate_algorithm.txt for the output which compares:
    #   1) The ratings posted on the bayoen.fr world ranking page as of February 2020.
    #   2) The ratings generated by the original Java code (with minor adjustments).
    #   3) The ratings generated by the Python code adaptation.

    asof_date = datetime(2020, 2, 1, tzinfo=timezone.utc)

    def timer(msg, start):
        end = time.time()
        print("   - {} ({:0.1f}s elapsed)".format(msg, end - start))
        return end

    # Open the hikuwr database and query all matches prior to February 2020.
    print(
        "validate_algorithm (as of {}, {:d} iterations)".format(
            asof_date.strftime("%d/%m/%y"), iterations
        )
    )
    with dbsession(dbname="hikuwr") as session:
        start = time.time()
        matches = (
            session.query(Match)
            .filter(Match.created <= asof_date)
            .order_by(asc(Match.created))
            .all()
        )
        start = timer("Load {:d} matches from database.".format(len(matches)), start)

        # Compute the results for comparison.
        wiki_results = load_wiki_results(session)
        start = timer("Load {:d} ratings from wiki.".format(len(wiki_results)), start)

        java_results = load_java_results(session, matches, asof_date, iterations)
        start = timer("Compute ratings with Java algorithm.", start)

        python_results = hikuwr_rating(matches, asof_date, iterations)
        start = timer("Compute ratings with Python algorithm.", start)

    # Get the set of players common to all three results, sorted by wiki minimum rating.
    players = set(wiki_results) & set(java_results) & set(python_results)
    players = sorted(players, key=lambda player: wiki_results[player].min, reverse=True)
    results = [
        ("wiki", wiki_results),
        ("java", java_results),
        ("python", python_results),
    ]

    # Write the results to file.
    filename = "validate_algorithm.txt"
    filepath = os.path.join(os.path.dirname(__file__), "results", filename)
    fstring = "{src}\t{name}\t{min:0.2f}\t{med:0.2f}\t{max:0.2f}\n"
    with open(filepath, "w", encoding="utf-8") as file:
        file.write("Ratings as of " + asof_date.strftime("%d/%m/%y") + ".\n")
        file.write(str(iterations) + " iterations.\n\n")
        for player in players:
            for src, result in results:
                file.write(
                    fstring.format(
                        src=src,
                        name=player.name,
                        min=result[player].min,
                        med=result[player].med,
                        max=result[player].max,
                    )
                )
            file.write("\n")


def load_wiki_results(session):
    # Load the dateset from the text file.
    filepath = os.path.join(os.path.dirname(__file__), "source", "ratings_feb_2020.txt")
    with open(filepath, "r", encoding="utf-8") as file:
        lines = file.readlines()

    # Parse the dataset and return a dictionary. Query the database by player name.
    decimal = r"\s(\d+.\d\d)"
    pattern = r"^\d+\s(\S+)\s\S+" + decimal * 3 + "$"
    ratings = dict()
    for match in [re.match(pattern, line) for line in lines]:
        if match is None:
            continue

        player = session.query(Player).filter(Player.name == match.group(1)).first()

        if player is not None:
            ratings[player] = Rating(
                min=float(match.group(2)),
                med=float(match.group(3)),
                max=float(match.group(4)),
            )

    return ratings


def load_java_results(session, matches, asof_date, iterations):
    jpype.startJVM(classpath=[os.path.join(os.path.dirname(__file__))])
    WorldRanking = jpype.JClass("source/WorldRanking")()

    for match in matches:
        WorldRanking.pythonAddMatch(
            match.playerA.name,
            match.playerB.name,
            match.scoreA,
            match.scoreB,
            match.created.strftime("%d/%m/%y"),
        )

    WorldRanking.pythonExecuteAlgorithm(iterations, asof_date.strftime("%d/%m/%y"))
    output = zip(
        WorldRanking.playerNames,
        WorldRanking.playerRatings,
        WorldRanking.playerLowerBounds,
        WorldRanking.playerUpperBounds,
    )
    results = {}
    for name, med_rating, lb_rating, ub_rating in output:
        player = session.query(Player).filter(Player.name == str(name)).one()
        rating = Rating(min=lb_rating, med=med_rating, max=ub_rating)
        results[player] = rating

    jpype.shutdownJVM()
    return results


def validate_convergence(iterations):
    # This routine will plot the algorithm converge metric over iterations.

    asof_date = datetime(2020, 2, 1, tzinfo=timezone.utc)

    # Open the hikuwr database and query all matches prior to February 2020.
    print(
        "validate_convergence (as of {}, {:d} iterations)".format(
            asof_date.strftime("%d/%m/%y"), iterations
        )
    )

    with dbsession(dbname="hikuwr") as session:
        matches = (
            session.query(Match)
            .filter(Match.created <= asof_date)
            .order_by(asc(Match.created))
            .all()
        )

        largest_deltas, average_deltas = hikuwr_rating(
            matches, asof_date, iterations, convergence=True
        )

    plt.semilogy(largest_deltas, label="largest rating change")
    plt.semilogy(average_deltas, label="average rating change")
    plt.title("Rating Change Over Iterations")
    plt.grid()
    plt.xlabel("Iterations")
    plt.ylabel("Rating Change")
    plt.legend()

    filepath = os.path.join(
        os.path.dirname(__file__), "results", "validate_convergence.png"
    )
    plt.savefig(filepath)


def main():
    if not len(sys.argv) > 1:
        parser.print_help()
        return

    args = parser.parse_args()
    if args.algorithm is not None:
        print()
        validate_algorithm(int(args.algorithm))
    if args.convergence is not None:
        print()
        validate_convergence(int(args.convergence))
